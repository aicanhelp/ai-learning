很可能您听说过以太坊区块链，无论您是否知道它是什么。它最近经常出现在新闻中，包括一些主要杂志的封面，但如果你不了解以太坊到底是什么，阅读这些文章可能就像胡言乱语。那是什么？从本质上讲，这是一个保留数字交易永久记录的公共数据库。重要的是，这个数据库不需要任何中央机构来维护和保护它。相反，它作为一个“无需信任”的交易系统运行——一个个人可以在不需要信任第三方或彼此的情况下进行点对点交易的框架。                                   

还是一头雾水？这就是这篇文章的用武之地。我的目标是解释以太坊如何在技术层面发挥作用，而不需要复杂的数学或看起来很吓人的公式。即使您不是程序员，我也希望您至少能更好地掌握技术。如果某些部分技术性太强且难以理解，那完全没问题！真的没有必要了解每个小细节。我建议只关注在广泛层面上理解事物。

这篇文章中涵盖的许多主题都是对黄皮书中讨论的概念的细分。我添加了自己的解释和图表，以便更容易理解以太坊。勇于挑战技术的小伙伴也可以看看以太坊黄皮书。

让我们开始吧！

PS：如果您是一名开发人员，有兴趣学习如何在以太坊上构建 Dapp，请加入我的[新课程。](https://www.dappcamp.xyz/)

## 区块链定义

区块链是“**具有共享状态的加密安全事务单机”。**[1] 那是一口，不是吗？让我们分解一下。

- **“密码学安全”** 意味着数字货币的创建受到极其难以破解的复杂数学算法的保护。想想各种各样的防火墙。它们几乎不可能欺骗系统（例如创建虚假交易、删除交易等）
- **“交易单例机”** 意味着有一个机器的单一规范实例负责在系统中创建的所有交易。换句话说，每个人都相信一个全球真理。
- **“With shared-state”** 意味着存储在这台机器上的状态是共享的，对所有人开放。

以太坊实现了这种区块链范式。

## 以太坊区块链范式解释

以太坊区块链本质上是一个**基于交易的** **状态机**。在计算机科学中，*状态机*指的是将读取一系列输入并根据这些输入转换到新状态的东西。

![](https://uploads-ssl.webflow.com/5ddd80927946cdaa0e71d607/5ddd80927946cd3f7871d6f2_how-does-ethereum-work-anyway-1.png)

对于以太坊的状态机，我们从“创世状态”开始。这类似于一张白纸，在网络上发生任何交易之前。当交易被执行时，这个创世状态转变为某个最终状态。在任何时间点，这个最终状态代表了以太坊的当前状态。

![](https://uploads-ssl.webflow.com/5ddd80927946cdaa0e71d607/5ddd80927946cdd1dd71d6f1_how-does-ethereum-work-anyway-2.png)

以太坊的状态有数百万笔交易。这些交易被分组为“块”。一个区块包含一系列交易，每个区块都与其前一个区块链接在一起。

![](https://uploads-ssl.webflow.com/5ddd80927946cdaa0e71d607/5ddd80927946cde00871d6f5_how-does-ethereum-work-anyway-3.png)

要引起从一个状态到下一个状态的转换，交易必须是有效的。**要使交易被视为有效，它必须经过称为挖矿的验证过程。** 挖矿是指一组节点（即计算机）耗费其计算资源来创建有效交易块。

网络上任何声明自己为矿工的节点都可以尝试创建和验证区块。来自世界各地的许多矿工试图同时创建和验证区块。每个矿工在向区块链提交区块时都会提供一个数学“证明”，这个证明起到保证的作用：如果证明存在，那么这个区块就一定是有效的。

对于要添加到主区块链的区块，矿工必须比任何其他竞争矿工更快地证明它。通过让矿工提供数学证明来验证每个区块的过程称为 **“工作量证明”。**

验证新区块的矿工因完成这项工作而获得一定数量的奖励。那是什么价值？以太坊区块链使用一种称为“以太”的固有数字令牌。每次矿工证明一个区块时，都会生成并奖励新的以太币。

你可能想知道：什么保证每个人都坚持一个区块链？我们如何确定不存在决定创建自己的区块链的矿工子集？

早些时候，我们将区块链定义为**具有共享状态的事务性单例机**。使用这个定义，我们可以理解正确的当前状态是一个单一的全球真理，每个人都必须接受。拥有多个状态（或链）会破坏整个系统，因为不可能就哪个状态是正确的状态达成一致。如果链分叉，您可能在一个链上拥有 10 个硬币，在另一个链上拥有 20 个硬币，在另一个链上拥有 40 个硬币。在这种情况下，无法确定哪条链是最“有效”的。

每当生成多条路径时，就会出现“分叉”。我们通常希望避免分叉，因为它们会破坏系统并迫使人们选择他们“相信”的链。

![](https://uploads-ssl.webflow.com/5ddd80927946cdaa0e71d607/5ddd80927946cde2ec71d6fa_how-does-ethereum-work-anyway-4.png)

为了确定哪条路径最有效并防止出现多个链，以太坊使用一种称为 **“GHOST 协议” 的机制。**

#### **“GHOST” = “贪婪的最重观察子树”**

简而言之，**GHOST 协议规定我们必须选择已完成最多计算的路径**。确定该路径的一种方法是使用最近区块（“叶区块”）的区块编号，它代表当前路径中的区块总数（不包括创世区块）。块数越高，路径越长，到达叶节点的挖掘工作量就越大。使用这种推理可以让我们就当前状态的规范版本达成一致。

![](https://uploads-ssl.webflow.com/5ddd80927946cdaa0e71d607/5ddd80927946cd6cec71d6f3_how-does-ethereum-work-anyway-5.png)

现在您已经对什么是区块链有了 10,000 英尺的概览，让我们更深入地了解以太坊系统的主要组成部分：

- 帐户
- 状态
- 天然气和费用
- 交易
- 积木
- 交易执行
- 矿业
- 工作证明

*开始之前的一个注意事项：每当我说 X 的“哈希”时，我指的是以太坊使用的* [*KECCAK-256*](https://ethereum.stackexchange.com/questions/550/which-cryptographic-hash-function-does-ethereum-use) *哈希。*

#### 帐户

以太坊的全球“共享状态”由许多能够通过消息传递框架相互交互的小对象（“账户”）组成。每个账户都有一个与之关联的**状态**和一个 20 字节的**地址**。以太坊中的地址是一个 160 位的标识符，用于标识任何帐户。

有两种类型的帐户：

- 外部拥有的帐户，**由私钥控制**并且**没有与之关联的代码。**
- 合约账户，由其**合约代码控制**并**具有与之关联的代码。**

![](https://uploads-ssl.webflow.com/5ddd80927946cdaa0e71d607/5ddd80927946cd7d7f71d6f4_how-does-ethereum-work-anyway-6.png)

#### 外部账户与合约账户

了解外部拥有账户和合同账户之间的根本区别很重要。**外部拥有的帐户可以通过使用其私钥创建和签署交易来向其他外部拥有的帐户或其他合约帐户发送消息。** 两个外部拥有的帐户之间的消息只是一个价值转移。但是从外部拥有的账户到合约账户的消息会激活合约账户的代码，允许它执行各种操作（例如转移代币、写入内部存储、铸造新代币、执行一些计算、创建新合约等）。

**与外部拥有的账户不同，合约账户不能自行发起新的交易。** 相反，合约账户只能触发交易以响应他们收到的其他交易（来自外部拥有的账户或另一个合约账户）。*我们将在“交易和消息*”部分了解更多关于合约到合约调用的信息。

![](https://uploads-ssl.webflow.com/5ddd80927946cdaa0e71d607/5ddd80927946cd3bf271d6fb_how-does-ethereum-work-anyway-7.png)

**因此，以太坊区块链上发生的任何动作总是由外部控制的账户触发的交易启动。**

![](https://uploads-ssl.webflow.com/5ddd80927946cdaa0e71d607/5ddd80927946cdf27571d6f6_how-does-ethereum-work-anyway-8.png)

#### 帐户状态

帐户**状态**由四个部分组成，无论帐户类型如何，它们都会存在：

- **nonce**：如果账户是外部账户，这个数字代表从账户地址发送的交易数量。如果账户是合约账户，nonce就是该账户创建的合约数量。
- **balance**：该地址拥有的 Wei 数量。每个以太有 1e+18 Wei。
- **storageRoot**：Merkle Patricia 树的根节点的哈希值（稍后我们将解释 Merkle 树）。这棵树对本账户存储内容的哈希进行编码，默认为空。
- **codeHash**：此帐户的 EVM（以太坊虚拟机——稍后会详细介绍）代码的哈希值。**对于合约账户，这是经过哈希处理并存储为codeHash 的**代码。对于外部拥有的帐户，**codeHash**字段是空字符串的哈希值。

![](https://uploads-ssl.webflow.com/5ddd80927946cdaa0e71d607/5ddd80927946cd00a771d6f7_how-does-ethereum-work-anyway-9.png)

#### 世界状态

好的，所以我们知道以太坊的全局状态由账户地址和账户状态之间的映射组成。此映射存储在称为**Merkle Patricia 树的**数据结构中。

Merkle 树（或也称为“Merkle trie”）是一种[二叉树](https://en.wikipedia.org/wiki/Binary_tree)，由一组节点组成，这些节点具有：

- 树底部的大量叶节点包含基础数据
- 一组中间节点，其中每个节点是其两个子节点的散列
- 单个根节点，也由其两个子节点的哈希值形成，代表树的顶部

![](https://uploads-ssl.webflow.com/5ddd80927946cdaa0e71d607/5ddd80927946cda1fe71d6f8_how-does-ethereum-work-anyway-10.png)

树底部的数据是通过将我们要存储的数据拆分成*块*，然后将块拆分成*桶*，然后取每个桶的哈希并重复相同的过程，直到剩余的哈希总数变为只有一个：**根哈希。**

![](https://uploads-ssl.webflow.com/5ddd80927946cdaa0e71d607/5ddd80927946cd7b7371d6f9_how-does-ethereum-work-anyway-11.png)

这棵树需要为其中存储的每个值都有一个键。从树的根节点开始，键应该告诉你要跟随哪个子节点才能得到相应的值，该值存储在叶节点中。在以太坊的例子中，状态树的键/值映射在地址和它们的关联账户之间，包括每个账户的余额、随机数、codeHash 和 storageRoot（其中 storageRoot 本身就是一棵树）。

![](https://uploads-ssl.webflow.com/5ddd80927946cdaa0e71d607/5ddd80927946cd40ba71d6fc_how-does-ethereum-work-anyway-12.png)

*资料来源：以太坊白皮书*

同样的特里结构也用于存储交易和收据。更具体地说，每个区块都有一个“头部”，其中存储了三种不同 Merkle trie 结构的根节点的哈希值，包括：

1. 状态特里
2. 交易特里
3. 收据特里

![](https://uploads-ssl.webflow.com/5ddd80927946cdaa0e71d607/5ddd80927946cdd71571d6ff_how-does-ethereum-work-anyway-23.png)

在 Merkle 尝试中有效存储所有这些信息的能力在以太坊中对于我们所谓的“轻客户端”或“轻节点”非常有用。请记住，区块链由一堆节点维护。从广义上讲，有两种类型的节点：全节点和轻节点。

**一个完整的存档节点通过下载完整的链来同步区块链，从创世块到当前的头块，执行其中包含的所有交易。**通常，矿工存储完整的存档节点，因为他们需要为挖掘过程这样做。也可以在不执行每个事务的情况下下载完整节点。无论如何，任何完整节点都包含整个链。

但除非节点需要执行每笔交易或轻松查询历史数据，否则实际上没有必要存储整个链。这就是轻节点概念的用武之地。轻节点**不是下载和存储完整的链并执行所有交易，而是只下载从创世块到当前头部的头部链，而不执行任何交易或检索任何关联的状态。**由于轻节点可以访问包含三次尝试的哈希值的区块头，它们仍然可以轻松生成和接收有关交易、事件、余额等的可验证答案。

这样做的原因是因为 Merkle 树中的哈希向上传播——如果恶意用户试图将虚假交易交换到 Merkle 树的底部，这种变化将导致上面节点的哈希发生变化，这将改变上面节点的散列，依此类推，直到它最终改变树的根。

![](https://uploads-ssl.webflow.com/5ddd80927946cdaa0e71d607/5ddd80927946cd840171d700_how-does-ethereum-work-anyway-14.png)

任何想要验证一段数据的节点都可以使用称为“Merkle 证明”的东西来这样做。Merkle 证明包括：

1. 要验证的数据块及其哈希
2. 树的根哈希
3. “分支”（所有伙伴散列沿着从块到根的路径上升）

![](https://uploads-ssl.webflow.com/5ddd80927946cdaa0e71d607/5ddd80927946cd5c2a71d6fd_how-does-ethereum-work-anyway-15.png)

任何阅读证明的人都可以验证该分支的散列在树上一直是一致的，因此给定的块实际上位于树中的那个位置。

**总之，使用 Merkle Patricia 树的好处是该结构的根节点在密码学上依赖于存储在树中的数据，因此根节点的哈希值可以用作该数据的安全身份。由于区块头包含状态、交易和收据树的根哈希，因此任何节点都可以验证以太坊状态的一小部分，而无需存储整个状态，而整个状态的大小可能是无限的。**

### 天然气和付款

以太坊中一个非常重要的概念是费用的概念。**由于以太坊网络上的交易而发生的每一次计算都会产生费用——天下没有免费的午餐！**该费用以称为“gas”的面额支付。

**Gas**是用于衡量特定计算所需费用的单位。**Gas Price**是您愿意在每单位 Gas 上花费的以太币数量，以“gwei”衡量。“Wei”是以太的最小单位，1⁰¹⁸ Wei代表1个以太。一 gwei 是 1,000,000,000 Wei。

对于每笔交易，发件人都会设置**gas limit**和**gas price**。**gas price**和**gas limit**的乘积代表发送方愿意为执行交易支付的最大 Wei 数额。

例如，假设发送方将 gas limit 设置为 50,000，将 gas price 设置为 20 gwei。这意味着发送方最多愿意花费 50,000 x 20 gwei = 1,000,000,000,000,000 Wei = 0.001 Ether 来执行该交易。

![](https://uploads-ssl.webflow.com/5ddd80927946cdaa0e71d607/5ddd80927946cdfa2071d6fe_how-does-ethereum-work-anyway-16.png)

请记住，gas limit 代表发件人愿意花钱购买的最大 gas。如果他们的账户余额中有足够的以太币来支付这个最大值，他们就可以开始了。在交易结束时，发件人将退还任何未使用的气体，并按原始汇率兑换。

![](https://uploads-ssl.webflow.com/5ddd80927946cdaa0e71d607/5ddd80927946cd10b071d701_how-does-ethereum-work-anyway-17.png)

如果发送方未提供执行交易所需的气体，则交易“耗尽气体”并被视为无效。在这种情况下，交易处理中止并且发生的任何状态变化都被逆转，这样我们最终会回到交易前的以太坊状态。此外，交易失败的记录会被记录下来，显示尝试了什么交易以及失败的地方。由于机器在耗尽 gas 之前已经付出了努力来运行计算，因此从逻辑上讲，**没有任何 gas 会退还给发送者。**

![](https://uploads-ssl.webflow.com/5ddd80927946cdaa0e71d607/5ddd80927946cd530271d703_how-does-ethereum-work-anyway-18.png)

这笔汽油钱到底去了哪里？**发件人在 gas 上花费的所有钱都发送到“受益人”地址，通常是矿工的地址。**由于矿工正在花费精力来运行计算和验证交易，因此矿工会收到汽油费作为奖励。

![](https://uploads-ssl.webflow.com/5ddd80927946cdaa0e71d607/5ddd80927946cdc5ef71d702_how-does-ethereum-work-anyway-19.png)

通常，发送方愿意支付的 gas 价格越高，矿工从交易中获得的价值就越大。因此，矿工更有可能选择它。通过这种方式，矿工可以自由选择他们想要验证或忽略哪些交易。为了指导发件人设定什么 gas 价格，矿工可以选择公布他们将执行交易的最低 gas 价格。

#### 保管也要收费

**Gas 不仅用于支付计算步骤，还用于支付存储使用费用。**总存储费用与使用的 32 字节的最小倍数成正比。

存储费用有一些细微差别。例如，由于增加存储会增加*所有*节点上以太坊状态数据库的大小，因此有动机保持较小的数据存储量。出于这个原因，如果交易有一个清除存储中条目的步骤，则执行该操作的费用将被免除，并且会因释放存储空间而获得退款。

#### **收费的目的是什么？**

以太坊工作方式的一个重要方面是**网络执行的每一个操作都会同时受到每个完整节点的影响。**然而，以太坊虚拟机上的计算步骤非常昂贵。因此，以太坊智能合约最适用于简单的任务，例如运行简单的业务逻辑或验证签名和其他加密对象，而不是更复杂的用途，例如文件存储、电子邮件或机器学习，它们会给网络带来压力。**征收费用可防止用户使网络负担过重。**

以太坊是一种图灵完备的语言。（简而言之，图灵机是一种可以模拟任何计算机算法的机器（对于那些不熟悉图灵机的人，请查看[这个](https://en.wikipedia.org/wiki/Turing_machine)和[这个](http://mathworld.wolfram.com/TuringMachine.html)）。这允许循环并使以太坊容易受到[停机问题](https://en.wikipedia.org/wiki/Halting_problem)的影响，这个问题你无法确定程序是否会无限运行。如果没有费用，恶意行为者可以很容易地通过在交易中执行无限循环来破坏网络，而不会产生任何影响。因此，费用可以保护网络免受蓄意攻击。

您可能会想，“为什么我们还必须为存储付费？” 好吧，就像计算一样，以太坊网络上的存储是整个网络必须承担的成本。

## 交易和消息

我们之前注意到，以太坊是一个**基于交易的状态机。**换句话说，不同账户之间发生的交易将以太坊的全球状态从一种状态转移到另一种状态。

**在最基本的意义上，交易是一段加密签名的指令，由外部拥有的账户生成、序列化，然后提交到区块链。**

有两种类型的交易：**消息调用**和**合约创建**（即创建新的以太坊合约的交易）。

所有交易都包含以下组件，无论其类型如何：

- **nonce**：发送方发送的交易数量的计数。
- **gasPrice**：发送方愿意为执行交易所需的每单位 gas 支付的 Wei 数量。
- **gasLimit**：发送方愿意为执行此交易支付的最大气体量。在完成任何计算之前，预先设置并支付此金额。
- **to**：收件人的地址。在创建合约的交易中，合约账户地址尚不存在，因此使用空值。
- **value**：从发送方转移到接收方的 Wei 数量。在合约创建交易中，此值用作新创建的合约账户中的起始余额。
- **v, r, s**：用于生成标识交易发送方的签名。
- **init**（仅存在于合约创建交易）：用于初始化新合约账户的 EVM 代码片段。**init**只运行一次，然后被丢弃。当**init**第一次运行时，它返回账户代码的主体，这是与合约账户永久关联的代码段。
- **data** (optional field that only exists for message calls)：消息调用的输入数据（即参数）。例如，如果智能合约用作域注册服务，则对该合约的调用可能需要输入域和 IP 地址等字段。

![](https://uploads-ssl.webflow.com/5ddd80927946cdaa0e71d607/5ddd80927946cd64ae71d704_how-does-ethereum-work-anyway-20.png)

我们在“*账户*”部分了解到交易——消息调用和合约创建交易——总是由外部拥有的账户发起并提交给区块链。另一种思考方式是，交易是外部世界与以太坊内部状态的桥梁。

![](https://uploads-ssl.webflow.com/5ddd80927946cdaa0e71d607/5ddd80927946cd808e71d705_how-does-ethereum-work-anyway-21.png)

但这并不意味着合约不能与其他合约对话。**存在于以太坊状态全球范围内的合约可以与同一范围内的其他合约进行对话。他们这样做的方式是通过向其他合约发送“消息”或“内部交易”。**我们可以将消息或内部交易视为类似于交易，主要区别在于它们不是由外部拥有的帐户生成的。相反，它们是由合同生成的。它们是虚拟对象，与交易不同，它们没有序列化，只存在于以太坊执行环境中。

**当一个合约向另一个合约发送内部交易时，执行接收方合约账户上存在的关联代码。**

![](https://uploads-ssl.webflow.com/5ddd80927946cdaa0e71d607/5ddd80927946cd6e7771d708_how-does-ethereum-work-anyway-22.png)

需要注意的一件重要事情是内部交易或消息不包含**gasLimit。**这是因为气体限制是由原始交易的外部创建者（即一些外部拥有的账户）决定的。外部拥有账户设置的气体限制必须足够高以执行交易，包括作为该交易的结果发生的任何子执行，例如合约到合约的消息。如果在交易和消息链中，特定消息的执行耗尽了 gas，那么该消息的执行将与执行触发的任何先前消息一起恢复。唯一的例外是如果您在合约中使用原始 CALL 操作码（除非您完全知道自己在做什么，否则不推荐这样做）。在这种情况下，调用另一个合约可能会失败，但如果父合约不检查并处理该错误，

## 积木

所有交易都被组合成“块”。区块链包含一系列链接在一​​起的此类块。

在以太坊中，一个区块包括：

- **块头**_
- 有关该块中包含**的交易集的信息**
- 当前块的 ommers 的一**组其他块头**。

#### 毕竟解释了

“ommer”到底是什么？ommer 是一个块，其父块等于当前块的父块的父块。让我们快速了解一下 ommer 的用途以及为什么区块包含 ommer 的区块头。

由于以太坊的构建方式，出块时间（约 15 秒）远低于其他区块链，如比特币（约 10 分钟）。这可以实现更快的事务处理。然而，较短出块时间的缺点之一是矿工会发现更多竞争性出块解决方案。这些竞争块也被称为“孤立块”（即开采的块不会进入主链）。

ommers 的目的是帮助奖励包含这些孤立区块的矿工。矿工包含的 ommer 必须是“有效的”，这意味着在当前区块的第六代或更小的代内。在六个孩子之后，陈旧的孤立块不能再被引用（因为包括较旧的交易会使事情变得有点复杂）。

Ommer 块收到的奖励比完整块少。尽管如此，矿工仍然有一些动机将这些孤立的区块包括在内并获得回报。

#### 块头

让我们暂时回到块上。我们之前提到每个区块都有一个区块“头”，但这到底是什么？

区块头是区块的一部分，包括：

- **parentHash**：父块头的哈希值（这就是使块设置为“链”的原因）
- **ommersHash**：当前区块的 ommers 列表的哈希值
- **beneficiary** : 接收该区块挖矿费用的账户地址
- **stateRoot**：状态 trie 根节点的哈希值（回想一下我们是如何了解到状态 trie 存储在标头中并使轻客户端可以轻松验证有关状态的任何内容）
- **transactionsRoot**：包含此块中列出的所有交易的 trie 的根节点的哈希值
- **receiptsRoot**：包含此块中列出的所有交易的收据的 trie 的根节点的哈希值
- **logsBloom**：由日志信息组成的[布隆过滤器](https://en.wikipedia.org/wiki/Bloom_filter)（数据结构）
- **difficulty** : 这个块的难度级别
- **number** : 当前块的计数（创世块的块号为零；每个后续块块号增加 1）
- **gasLimit**：当前每个区块的气体限制
- **gasUsed**：该区块中交易使用的总gas总和
- **timestamp** : 这个块开始的 unix 时间戳
- **extraData** : 与此块相关的额外数据
- **mixHash**：一个散列，当与随机数结合时，证明这个块已经进行了足够的计算
- **nonce** : 一个哈希，当与 mixHash 结合时，证明这个块已经进行了足够的计算

![](https://uploads-ssl.webflow.com/5ddd80927946cdaa0e71d607/5ddd80927946cdd71571d6ff_how-does-ethereum-work-anyway-23.png)

注意每个区块头是如何包含三个 trie 结构的：

- 状态（**状态根**）
- 交易（**交易根**）
- 收据（**收据根**）

这些 trie 结构只不过是我们之前讨论过的 Merkle Patricia 尝试。

此外，上述描述中有一些术语值得澄清。让我们来看看。

#### 日志

以太坊允许使用日志来跟踪各种交易和消息。合约可以通过定义它想要记录的“事件”来显式生成日志。

日志条目包含：

- 记录者的账户地址，
- 代表此交易执行的各种事件的一系列主题，以及
- 与这些事件相关的任何数据。

日志存储在[bloom filter](https://en.wikipedia.org/wiki/Bloom_filter)中，它以高效的方式存储无穷无尽的日志数据。

#### 交易收据

头部存储的日志来自交易回执中包含的日志信息。就像您在商店购物时会收到收据一样，以太坊会为每笔交易生成收据。如您所料，每张收据都包含有关交易的特定信息。此收据包括以下项目：

- 块号
- 块散列
- 交易哈希
- 当前交易使用的gas
- 当前交易执行后，当前区块使用的累计gas
- 执行当前事务时创建的日志
- ..等等

#### 区块难度

块的“难度”用于强制验证块所需时间的一致性。创世区块的难度为 131,072，之后每个区块的难度都采用特殊公式计算。如果某个区块的验证速度比前一个区块快，则以太坊协议会增加该区块的难度。

区块的难度会影响**随机数，随机数**是在使用工作量证明算法挖掘区块时必须计算的哈希值。

区块的**难度**和**nonce**之间的关系在数学上形式化为：

![](https://uploads-ssl.webflow.com/5ddd80927946cdaa0e71d607/5ddd80927946cde06571d706_how-does-ethereum-work-anyway-24.png)

*其中* ***Hd*** *是难度。*

找到满足难度阈值的随机数的唯一方法是使用工作量证明算法来枚举所有可能性。找到解决方案的预期时间与难度成正比——难度越高，找到 nonce 就越难，因此验证块就越难，这反过来又增加了验证新块所需的时间堵塞。**因此，通过调整区块的难度，协议可以调整验证区块所需的时间。**

另一方面，如果验证时间变慢，则协议会降低难度。通过这种方式，验证时间会自我调整以保持恒定的速率——平均每 15 秒一个块。

## 交易执行

我们来到了以太坊协议中最复杂的部分之一：交易的执行。假设您将交易发送到以太坊网络进行处理。将以太坊状态转变为包括您的交易会发生什么？

![](https://uploads-ssl.webflow.com/5ddd80927946cdaa0e71d607/5ddd80927946cd7a7d71d707_how-does-ethereum-work-anyway-25.png)

首先，所有交易都必须满足一组初始要求才能执行。这些包括：

- 交易必须是格式正确的**RLP**。“RLP”代表“递归长度前缀”，是一种用于编码嵌套二进制数据数组的数据格式。RLP 是以太坊用来序列化对象的格式。
- 有效的交易签名。
- 有效的交易随机数。回想一下，帐户的随机数是从该帐户发送的交易计数。为了有效，交易随机数必须等于发件人账户的随机数。
- 交易的 gas limit 必须等于或大于交易使用的**固有 gas**。本征气体包括：
- 1) 执行交易的预定义成本为 21,000 gas
- 2) 随交易发送的数据的 gas 费用（每个字节的数据或代码等于 0 需要 4 gas，每个非零字节的数据或代码需要 68 gas）
- 3）如果交易是合约创建交易，额外32,000 gas
- 4) transaction执行的每个操作的gas成本（[见附录G](https://ethereum.github.io/yellowpaper/paper.pdf)）

![](https://uploads-ssl.webflow.com/5ddd80927946cdaa0e71d607/61c929aa1a63684114883d11_Screen%20Shot%202021-12-26%20at%206.48.40%20PM.png)

- 发件人的账户余额必须有足够的以太币来支付发件人必须支付的**“前期”gas 费用。**前期gas成本的计算很简单：首先，交易的**gas limit**乘以交易的**gas价格**来确定最大gas成本。然后，这个最大成本被添加到从发送者转移到接收者的总价值中。

![](https://uploads-ssl.webflow.com/5ddd80927946cdaa0e71d607/5ddd80927946cdd3a871d70b_how-does-ethereum-work-anyway-27.png)

如果交易满足上述所有有效性要求，那么我们将进入下一步。

首先，我们从发送方的余额中扣除执行的前期成本，并将发送方账户的随机数增加 1 以计入当前交易。此时，我们可以将剩余的气体计算为**交易的总气体限额减去使用的固有气体。**

![](https://uploads-ssl.webflow.com/5ddd80927946cdaa0e71d607/61c929c2ab9205538425d9ed_Screen%20Shot%202021-12-26%20at%206.48.50%20PM.png)

接下来，事务开始执行。在整个交易执行过程中，以太坊会跟踪“子状态”。此子状态是一种记录事务期间累积的信息的方法，事务完成后将立即需要这些信息。具体来说，它包含：

- **自毁集**：交易完成后将被丢弃的一组账户（如果有的话）。
- **日志系列**：虚拟机代码执行的存档和可索引检查点。
- **Refund balance** : 交易后要退还给汇款人账户的金额。还记得我们如何提到以太坊中的存储是要花钱的，而发件人会因清理存储而得到退款吗？以太坊使用退款计数器跟踪这一点。退款计数器从零开始，并在每次合约删除存储中的内容时递增。

接下来，处理交易所需的各种计算。

一旦处理了交易所需的所有步骤，并且假设没有无效状态，则通过确定要退还给发送方的未使用气体量来最终确定状态。除了未使用的 gas 之外，发件人还会从我们上面描述的“退款余额”中退还一些津贴。

一旦发件人被退款：

- 气体的以太币被提供给矿工
- 交易使用的气体被添加到区块气体计数器（它跟踪区块中所有交易使用的气体总量，在验证区块时很有用）
- 自毁集中的所有帐户（如果有）都被删除

最后，我们留下了新状态和一组由事务创建的日志。

现在我们已经介绍了交易执行的基础知识，让我们看一下合约创建交易和消息调用之间的一些区别。

#### 合约创建

回想一下，在以太坊中，有两种类型的账户：合约账户和外部拥有账户。当我们说交易是“合约创建”时，我们的意思是交易的目的是创建一个新的合约账户。

为了创建一个新的合约账户，我们首先使用一个特殊的公式声明新账户的地址。然后我们通过以下方式初始化新帐户：

- 将随机数设置为零
- 如果发件人发送了一定数量的以太币作为交易*价值*，将账户余额设置为该值
- 从发件人的余额中扣除添加到这个新帐户余额中的值
- 将存储设置为空
- 将合约的 codeHash 设置为空字符串的哈希值

一旦我们初始化了账户，我们实际上可以创建账户，使用与交易一起发送的**初始化代码**（请参阅“交易和消息”部分以重温初始化代码）。执行此初始化代码期间发生的情况各不相同。根据合约的构造函数，它可能会更新帐户的存储、创建其他合约帐户、进行其他消息调用等。

当执行初始化合约的代码时，它会使用 gas。**不允许交易消耗的 gas 多于剩余的 gas。如果是这样，执行将遇到 out-of-gas (OOG) 异常并退出。如果交易因气体不足异常而退出，则状态将恢复到交易前的状态。发件人不会*退还*用完之前消耗的气体。**

嘘。

但是，如果发送方在交易中发送了任何 Ether 值，即使合约创建失败，Ether 值也将被退还。呸！

如果初始化代码成功执行，则支付最终合约创建成本。这是存储成本，与创建的合约代码的大小成正比（同样，天下没有免费的午餐！）如果没有足够的剩余 gas 来支付最终成本，则交易再次声明 out-of-gas 异常并且中止。

如果一切顺利并且我们无一例外地做到了这一点，那么任何剩余的未使用的气体将退还给交易的原始发送者，并且现在允许改变的状态持续存在！

万岁！

#### 留言来电

消息调用的执行类似于合约创建，但有一些不同。

消息调用执行不包括任何初始化代码，因为没有创建新帐户。但是，它可以包含输入数据，如果该数据是由交易发送方提供的。执行后，消息调用还有一个包含输出数据的额外组件，如果后续执行需要此数据，则使用该组件。

与合约创建一样，如果消息调用执行因为耗尽 gas 或交易无效（例如堆栈溢出、无效跳转目的地或无效指令）而退出，则所使用的 gas 不会退还给原始调用者. 取而代之的是，所有剩余未使用的气体都被消耗掉，状态被重置到平衡转移之前的状态。

在以太坊的最新更新之前，如果系统不消耗您提供的所有气体，就无法停止或恢复交易的执行。例如，假设您编写了一个合约，当调用者未被授权执行某些交易时会抛出错误。在之前的以太坊版本中，剩余的gas仍然会被消耗掉，并且不会将gas退还给发送方。**但是拜占庭更新包括一个新的“还原”代码，允许合约停止执行并还原状态更改，而无需消耗剩余的气体，并且能够返回交易失败的原因。**如果交易因还原而退出，则未使用的气体将返回给发件人。

## 执行模型

到目前为止，我们已经了解了事务从开始到结束必须执行的一系列步骤。现在，我们来看看事务是如何在 VM 中实际执行的。

**协议中实际处理交易的部分是以太坊自己的虚拟机，称为以太坊虚拟机 (EVM)。**

如前所述，EVM 是一个图灵完备的虚拟机。EVM 具有典型图灵完备机没有的唯一限制是 EVM 本质上受气体约束。因此，可以完成的计算总量本质上受限于提供的气体量。

![](https://uploads-ssl.webflow.com/5ddd80927946cdaa0e71d607/5ddd80927946cd1aad71d70d_how-does-ethereum-work-anyway-29.png)

*资料来源：卡内基梅隆大学*

此外，EVM 具有基于堆栈的架构。堆栈[机](https://en.wikipedia.org/wiki/Stack_machine)是一种使用后进先出堆栈来保存临时值的计算机。

EVM 中每个堆栈项的大小为 256 位，堆栈的最大大小为 1024。

EVM 具有内存，其中项目存储为字寻址字节数组。内存是易失的，这意味着它不是永久的。

EVM 也有存储。与内存不同，存储是非易失性的，并且作为系统状态的一部分进行维护。EVM 将程序代码单独存储在只能通过特殊指令访问的虚拟[ROM中。](https://en.wikipedia.org/wiki/Read-only_memory)这样，EVM 不同于典型的[冯·诺依曼架构](https://en.wikipedia.org/wiki/Von_Neumann_architecture)，在后者中，程序代码存储在内存或存储器中。

![](https://uploads-ssl.webflow.com/5ddd80927946cdaa0e71d607/5ddd80927946cd477471d70e_how-does-ethereum-work-anyway-30.png)

EVM 也有自己的语言：“EVM 字节码”。当像你我这样的程序员编写在以太坊上运行的智能合约时，我们通常会使用更高级的语言（例如 Solidity）编写代码。然后我们可以将其编译为 EVM 可以理解的 EVM 字节码。

好的，现在开始执行。

在执行特定计算之前，处理器会确保以下信息可用且有效：

- 系统状态
- 计算剩余的gas
- 拥有正在执行的代码的帐户的地址
- 发起此执行的交易的发送者地址
- 导致代码执行的帐户地址（可能与原始发件人不同）
- 发起此执行的交易的汽油价格
- 本次执行的输入数据
- 作为当前执行的一部分传递到此帐户的值（以 Wei 为单位）
- 要执行的机器码
- 当前区块的区块头
- 当前消息调用或合约创建堆栈的深度

执行开始时，内存和堆栈为空，程序计数器为零。

PC：0 堆栈：[] 内存：[]，存储：{}

EVM 然后递归地执行交易，计算每个循环的**系统状态**和**机器状态**。系统状态就是以太坊的全局状态。机器状态包括：

- 可用气体
- 程序计数器
- 内存内容
- 内存中活跃的单词数
- 堆栈内容。

从系列的最左边部分添加或删除堆栈项。

在每个循环中，从剩余气体中减少适当的气体量，并且程序计数器递增。

在每个循环结束时，存在三种可能性：

1. 机器达到异常状态（例如，gas 不足、无效指令、堆栈项目不足、堆栈项目溢出超过 1024、无效的 JUMP/JUMPI 目的地等），因此必须停止，并丢弃任何更改
2. 序列继续处理进入下一个循环
3. 机器达到受控停止（执行过程结束）

假设执行没有遇到异常状态并达到“受控”或正常停止，机器会生成结果状态、执行后剩余的气体、累积的子状态和结果输出。

呸。我们通过了以太坊最复杂的部分之一。即使您没有完全理解这部分内容，也没关系。除非您在非常深的层次上工作，否则您*真的*不需要了解具体的执行细节。

#### 区块如何最终确定

最后，让我们看看一个包含许多交易的区块是如何被最终确定的。

当我们说“最终确定”时，它可能意味着两种不同的意思，这取决于区块是新区块还是现有区块。如果它是一个新块，我们指的是挖掘这个块所需的过程。如果它是一个现有的块，那么我们正在谈论验证块的过程。在任何一种情况下，“最终确定”一个块都有四个要求：

**1) 验证（或者，如果是挖矿，则确定）ommers 块头**  
中的每个 ommer 块必须是有效的头并且在当前块的第六代内。

**2) 验证（或者，如果是挖矿，则确定）交易**  
区块上的**gasUsed**数量必须等于区块中列出的交易使用的累计 gas。（回想一下，在执行交易时，我们会跟踪区块 gas 计数器，它会跟踪区块中所有交易使用的总 gas）。

**3) 申请奖励（仅在挖矿时）**  
受益人地址因挖区块而获得 5 个以太币。（根据以太坊提案[EIP-649](https://github.com/ethereum/EIPs/pull/669)，这个 5 ETH 的奖励将很快减少到 3 ETH）。此外，对于每个 ommer，当前区块的受益人将额外获得当前区块奖励的 1/32。最后，ommer 区块的受益人也会获得一定数量的奖励（有一个特殊的计算公式）。

**4) 验证（或者，如果是挖矿，则计算一个有效的）状态和随机数**  
确保应用所有交易和由此产生的状态变化，然后将新区块定义为区块奖励应用于最终交易的结果状态之后的状态。通过根据存储在标头中的状态特里检查此最终状态来进行验证。

## 挖矿工作量证明

“*区块*”部分简要介绍了区块难度的概念。赋予块难度意义的算法称为工作量证明（PoW）。

以太坊的工作量证明算法称为“ [Ethash](https://github.com/ethereum/wiki/wiki/Ethash) ”（以前称为 Dagger-Hashimoto）。

该算法正式定义为：

![](https://uploads-ssl.webflow.com/5ddd80927946cdaa0e71d607/5ddd80927946cd06eb71d70c_how-does-ethereum-work-anyway-31.png)

*其中* ***m*** *是* ***mixHash****，* ***n*** *是* ***nonce****，* ***Hn*** *是新块的头（不包括* *必须计算的****nonce*** *和* ***mixHash组件），*** ***Hn****是块头的 nonce ，****d****是*[*DAG*](https://en.wikipedia.org/wiki/Directed_acyclic_graph)*，它是一个大数据集。*[](https://en.wikipedia.org/wiki/Directed_acyclic_graph)

在“*区块*”部分，我们讨论了区块头中存在的各种项目。其中两个组件称为**mixHash**和**nonce**。你可能还记得：

- **mixHash**是一个散列，当与 nonce 结合时，证明这个块已经进行了足够的计算
- **nonce**是一个 hash，当它与 mixHash 结合时，证明这个块已经进行了足够的计算

PoW 函数用于评估这两项。

如何使用 PoW 函数准确计算**mixHash**和**nonce**有点复杂，我们可以在另一篇文章中深入探讨。但在高层次上，它是这样工作的：

为每个块计算一个“种子”。每个“纪元”的种子都是不同的，每个纪元有 30,000 个区块长。对于第一个时期，种子是一系列 32 字节零的哈希值。对于每个后续纪元，它是前一个种子哈希的哈希。使用这个种子，节点可以计算伪随机“缓存”。

这个缓存非常有用，因为它支持我们之前在本文中讨论过的“轻节点”的概念。轻节点的目的是为某些节点提供有效验证交易的能力，而无需存储整个区块链数据集的负担。轻节点可以仅基于这个缓存来验证交易的有效性，因为缓存可以重新生成它需要验证的特定块。

使用缓存，节点可以生成 DAG“数据集”，其中数据集中的每个项目都取决于缓存中的少量伪随机选择项目。为了成为一名矿工，你必须生成这个完整的数据集；所有完整的客户端和矿工都存储这个数据集，并且数据集随时间线性增长。

然后，矿工可以随机获取数据集的切片，并通过数学函数将它们散列在一起，形成一个“ **mixHash”。**” 矿工将重复生成**混合哈希**，直到输出低于所需的目标**随机数**。当输出满足这个要求时，这个随机数被认为是有效的，这个块可以被添加到链中。

#### **挖矿作为一种安全机制**

**‍ 总的来说**，PoW 的目的是以加密安全的方式证明特定数量的计算已被消耗以生成一些输出（即 nonce **）**。**这是因为除了枚举所有可能性之外，没有更好的方法来找到低于所需阈值的随机数。**重复应用哈希函数的输出具有均匀分布，因此我们可以确信，平均而言，**找到这样一个随机数所需的时间取决于难度阈值。**难度越高，解决 nonce 所需的时间就越长。通过这种方式，**PoW 算法赋予了难度概念意义，用于加强区块链安全性。**

区块链安全是什么意思？很简单：我们想创建一个每个人都信任的区块链。正如我们之前在这篇文章中讨论的那样，如果存在多个链，用户将失去信任，因为他们无法合理地确定哪条链是“有效”链。为了让一群用户接受存储在区块链上的底层状态，我们需要一个一群人都相信的单一规范区块链。

**这正是 PoW 算法所做的：它确保特定的区块链在未来仍然是规范的，这使得攻击者很难创建新的块来覆盖历史的特定部分（例如通过擦除交易或创建虚假交易）或维护叉子。**为了首先验证他们的区块，攻击者需要始终比网络中的任何其他人更快地解决 nonce，这样网络就会相信他们的链是最重的链（基于我们前面提到的 GHOST 协议的原则）。这是不可能的，除非攻击者拥有超过一半的网络挖矿能力，这种情况被称为多数[51% 攻击](https://en.bitcoin.it/wiki/Majority_attack)。

![](https://uploads-ssl.webflow.com/5ddd80927946cdaa0e71d607/5ddd80927946cdec6b71d70f_how-does-ethereum-work-anyway-32.png)

#### 挖矿作为一种财富分配机制

除了提供安全的区块链之外，PoW 还是一种将财富分配给那些使用计算来提供这种安全性的人的方式。回想一下，矿工因开采区块而获得奖励，包括：

- “获胜”区块的*静态区块奖励*为5 个以太币（即将[更改为 3 个以太币](https://github.com/ethereum/EIPs/pull/669)）
- 区块中包含的交易在区块内消耗的气体成本
- 将 ommers 作为区块的一部分的额外奖励

为了确保使用 PoW 共识机制进行安全和财富分配的长期可持续发展，以太坊努力灌输这两个属性：

- 让尽可能多的人可以访问它。换句话说，人们不需要专门的或不常见的硬件来运行算法。这样做的目的是让财富分配模型尽可能开放，这样任何人都可以提供任意数量的算力来换取以太币。
- 降低任何单个节点（或小节点）赚取不成比例利润的可能性。任何能够赚取不成比例利润的节点都意味着该节点对确定规范区块链具有很大的影响力。这很麻烦，因为它降低了网络安全性。

在比特币区块链网络中，与上述两个属性相关的一个问题是，PoW 算法是一种 SHA256 哈希函数。此类函数的弱点在于，使用专用硬件（也称为 ASIC）可以更有效地解决它。

为了缓解这个问题，以太坊选择使其 PoW 算法 ( [Ethhash](https://github.com/ethereum/wiki/wiki/Ethash) ) 顺序存储困难。这意味着该算法经过精心设计，因此计算随机数需要大量内存和带宽。大内存需求使得计算机很难并行使用其内存来同时发现多个随机数，而高带宽需求使得即使是超快的计算机也很难同时发现多个随机数。这降低了集中化的风险，并为进行验证的节点创造了一个更公平的竞争环境。

需要注意的一件事是，以太坊正在从 PoW 共识机制过渡到一种称为“权益证明”的机制。这本身就是一个令人毛骨悚然的话题，我们希望可以在以后的帖子中进行探讨。☺️

## 结论

……呸！你做到了最后。我希望？

我知道这篇文章中有很多内容需要消化。如果您需要多次阅读才能完全理解正在发生的事情，那完全没问题。在摸索到底发生了什么之前，我个人多次阅读了以太坊黄皮书、白皮书和代码库的各个部分。

尽管如此，我还是希望这篇概述对您有所帮助。如果您发现任何错误或错误，我希望您能写私信或直接在评论中发表。我保证，我看了他们所有人；）

请记住，我是人（是的，这是真的），我也会犯错误。为了社区的利益，我花时间免费写了这篇文章。因此，请在您的反馈中具有建设性，不要进行不必要的抨击。

想在收件箱中阅读我的故事吗？
